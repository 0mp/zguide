
++++ 0MQ Socket Patterns

Since 0MQ is designed to make distributed messaging easy, people often ask how to connect a set of peers to each other. Quite often the question comes to "why doesn't my ROUTER-to-ROUTER connection work?"

- why router-to-router won't work
    - dropping messages before connection
    - hwm drop action
    - unroutable drop action
- how we know sender of message
    - dealer isn't sufficient
    - router gives us that
    - setting identity before connect
- how we send back to specific node
    - cant use router
    - one dealer per peer
    - lookup dealer send to it
    - whether connected or not, great
- when do we destroy peer / socket
    - not immediately but after some time out
- draw the final scheme




What kind of 0MQ socket do we want for the connection? This question comes up on the {{zeromq-dev}} mailing list from time to time: how to interconnect peers where there's no server or client. People often try to use ROUTER sockets. I usually tell them that's hard to work with, because ROUTER sockets need some kind of address bootstrapping; you can't send a message until you know the identity of the peer, which you only learn when you get a message from them. So usually the answer is a DEALER-ROUTER mix where each peer has two sockets; DEALER to receive messages and ROUTER to send them.

However, we //do// have a way to bootstrap, since every node has its own UUID and this is compatible with ROUTER addressing. What we have to do is use the ZMQ_IDENTITY setting on our own ROUTER socket using our own UUID. So, let's try to use a single ROUTER for all input and all output and see if this works.

-> allow alternative discovery mechanisms
    - include endpoint in TCP beacon
    - if UDP broadcasts are disturbed, late, or 1-way
-> note cost of TCP beaconing
    - 100 x 100 x 30 = 300,000 bytes/second
    - will make a slow network dead
    so... only beacon nodes that haven't shown us love in a while
    tcp as more reliable fallback for UDP


    - taken from FILEMQ        - what if router connects to router
            - and router connects back to router
            - double connection with same identity?
        - hmm... not nice
            - beacon over tcp needs to provide port
            - otherwise we can't connect to it...
                - only on UDP packet
            - do we want to?
                - no... don't...
                - still, how to avoid two-redundant connection????
                - what happens then? is it even a problem
                    - make simple test case to find out
            - better
                - always bind using router socket
                - always connect out using dealer socket
                    - write on dealer socket
                        - won't work... or need separate dealer per router
                        - that's an idea
                    - no router socket... one dealer in, one out per peer
                    - means every message has to include sender address
                        - doable but not if the address is long
                        - too expensive
        - whole treatise on peer to peer topologies
            - how the fuck to make these...?
            - can we send peer a handle to use on replies?

        - i open dealer socket and bind to ephemeral port
        - i broadcast my port, anyone can reach me
        - protocol to establish identity of peer
            - security
            - handle for future work
        - this can then happen over any connection/reconnection


        so who connects to who?
        well, the server binds and the client... right
        this is why I say, don't do router to router
        it does not work
        there is no such thing as one pipe that is symetrical
        cause one end has to bind and one connect
        two pipes, at least... soprry folks


+++ Group Messaging

+++ File Transfer

+++ Event Synchronization

+++ Reliability

+++ Security

+++ Bridging

+++ Logging

+++ Simulation

(More coming soon)



Pieter Hintjens ‏@hintjens
Browser implementation of #zeromq patterns: https://github.com/progrium/nullmq  #nullmq
Expand

7m Pieter Hintjens ‏@hintjens
Node.js implementation of #zeromq patterns: https://github.com/visionmedia/axon … #axon
Expand

++++ The Messaging Layer

So we've solved discovery, presence, connectivity, and simulation. Next on our list: security, unicast messaging, and multicast messaging.

- SASL security


- one-to-one messaging by sending to node
- one-to-many messaging by sending to group
    - join group, leave group
    - group management across all nodes

++++ File Transfer

Take FILEMQ and plug into this framework.

Notes for The Guide
    
==1742== Syscall param write(buf) points to uninitialised byte(s)
==1742==    at 0x5372100: __write_nocancel (syscall-template.S:82)
==1742==    by 0x5306312: _IO_file_write@@GLIBC_2.2.5 (fileops.c:1289)
==1742==    by 0x53061D9: new_do_write (fileops.c:543)
==1742==    by 0x5307944: _IO_do_write@@GLIBC_2.2.5 (fileops.c:516)
==1742==    by 0x5306E6F: _IO_file_close_it@@GLIBC_2.2.5 (fileops.c:170)
==1742==    by 0x52FB2CF: fclose@@GLIBC_2.2.5 (iofclose.c:62)
==1742==    by 0x4060FF: fmq_file_test (fmq_file.c:342)
==1742==    by 0x4021E6: main (fmq_selftest.c:38)
==1742==  Address 0x4027000 is not stack'd, malloc'd or (recently) free'd

    FILE *handle = fopen ("testdata", "w");
    zmq_msg_t msg;
    zmq_msg_init_size (&msg, 100);
    size_t items = fwrite (zmq_msg_data (&msg), 1, 100, handle);
    fclose (handle);
    zmq_msg_close (&msg);

+++ Bridging

- why and how
- semantic compatibility
- example 0MQ to HTTP
- using zxxx library?

+++ Decentralised Logging System

- pubsub log events
- filter levels
- capture in log files or memory
- dynamic graphing
- log file cycling

+++ Timer Service

- ticks, 1/10, 1/100, etc.

+++ Disconnected Security
    
Chapter 9 topics

- the wire level protocol
- a minimal TCP stack
- internals of 0MQ
- generate bindings in
    Python
    C#
    Java
    Ruby



++++ Reliable Pipeline (Harmony Pattern)

0MQ's pipeline pattern (using PUSH and PULL sockets) is reliable to the extent that:

* Workers and collectors don't crash;
* Workers and collectors read their data fast enough to avoid queue overflows.

As with all our reliability patterns, we'll ignore what happens if an upstream node (the ventilator for a pipeline pattern) dies. In practice a ventilator will be the client of another reliability pattern, e.g. Clone.

The Harmony pattern takes pipeline and makes it robust against the only failure we can reasonably handle, namely workers and (less commonly) collectors that crash and lose messages or work.

- assume workers are idempotent
- assume batch size is known in advance (because...)
- assume memory enough to hold full batch
- batch: start (address of collector), tasks, end
- messages numbered 0 upwards inside batch
- assume multiple ventilators for same cluster
- assume collector talks to ventilator, (not same to allow walk-up-and use by ventilators)
- call ventilator the 'client'
- if task missing, resend
- if end of batch missing, resend from last response

