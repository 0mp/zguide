Chapter-Serialization-Languages Serialization Libraries
Binary-Star-Implementation Binary Star Reactor
Architecture-of-the-MQ-Community How to Make Really Large Architectures
Protocol-Assertions Binary Logging Protocol
Chapter-Cooperative-Discovery-using-UDP-Broadcasts Multiple Nodes on One Device
Chapter-Ping-Pong-Heartbeats State Machines
Chapter-The-Socket-API Plugging Sockets Into the Topology
The-ROUTER-to-ROUTER-Combination Invalid Combinations
Chapter-The-Hangman The Historian
Burnout Patterns for The Game
Upgrading-from-MQ-to-MQ Warning - Unstable Paradigms!
Advanced-Request-Reply-Patterns Request-Reply Envelopes
Vadim-Shalts-s-Story How the Guide Happened
the-community The ØMQ Community
Service-Oriented-Reliable-Queuing-Majordomo-Pattern Asynchronous Majordomo Pattern
Goals Preliminaries
Preemptive-Discovery-over-Raw-Sockets Cooperative Discovery using UDP Broadcasts
ROUTER-Broker-and-DEALER-Workers A Load-Balancing Message Broker
Chapter-Making-a-Clean-Exit Why We Needed ØMQ
Symbolic-Links Directory Replication
Chapter-Preemptive-Discovery-over-Raw-Sockets Cooperative Discovery using UDP Broadcasts
Messaging-Patterns High-level Messaging Patterns
Crazy-Beautiful-and-Easy Stranger, meet Stranger
Divide-and-Conquer Programming with ØMQ
Step-Draw-a-Rough-Architecture Step 3: Decide on the Contracts
Chapter-The-Human-Scale The Tale of Two Bridges
Group-Messaging Testing and Simulation
Basics Fixing the World
Chapter-Development-Process Creating Stable Releases
A-Minor-Note-on-Strings Version Reporting
Chapter-Testing-and-Simulation On Assertions
The-Flash-Mob The Canary Watcher
Chapter-A-High-Level-API-for-MQ Asynchronous Client-Server
Chapter-Surprise-and-Expectations Economics of Participation
ROUTER-Broker-and-REQ-Workers ROUTER Broker and DEALER Workers
Chapter-Authentication-using-SASL Large-scale File Publishing
Chapter-Serializing-your-Data Cheap and Nasty
Initial-Design-Cut-the-API Initial Design Cut - the Protocol
Chapter-Multiple-Nodes-on-One-Device Designing the API
Making-a-Clean-Exit Why We Needed ØMQ
Chapter-On-Assertions On Up-front Testing
-MQ-is-Not-a-Neutral-Carrier I/O Threads
Chapter-Spinning-off-a-Library-Project Point-to-point Messaging
Chapter-Conventions-Used-in-This-Book Using the Code Examples
Upfront-Coordination Scalability
Chapter-Detecting-Memory-Leaks Multithreading with ØMQ
Chapter-Establishing-the-Details Architecture of a Single Cluster
Why-We-Needed-MQ Socket Scalability
The-Zen-of-Zero How the Guide Happened
A-Shared-Key-Value-Cache-Clone-Pattern Distributing Key-Value Updates
Tom-van-Leeuwen-s-Story Michael Jakl's Story
A-Plausible-Minimal-Implementation Protocol Assertions
Chapter-Detecting-Disappearances Group Messaging
Using-Sockets-to-Carry-Data Unicast Transports
Chapter-Reliable-Request-Reply-Patterns What is "Reliability"?
Slow-Subscriber-Detection-Suicidal-Snail-Pattern High-speed Subscribers (Black Box Pattern)
Configuration File Stability
Chapter-Binary-Star-Implementation Binary Star Reactor
Chapter-The-Mindful-General The Social Engineer
How-the-Guide-Happened Removing Friction
Chapter-File-Stability Test Use Case
Chapter-Burnout Patterns for The Game
Chapter-How-to-Write-Unprotocols Why use the GPLv3 for Public Specifications?
Working-with-Messages Handling Multiple Sockets
Chapter-Asynchronous-Majordomo-Pattern Service Discovery
Chapter-Audience Conventions Used in This Book
Heartbeating Shrugging It Off
Chapter-Socket-Scalability Upgrading from ØMQ/2.2 to ØMQ/3.2
Binary-Star-Reactor Brokerless Reliability (Freelance Pattern)
Chapter-Cheap-and-Nasty ØMQ Framing
Chapter-The-Dynamic-Discovery-Problem Shared Queue (DEALER and ROUTER sockets)
Chapter-The-Tale-of-Two-Bridges Code on the Human Scale
Chapter-Using-Sockets-to-Carry-Data Unicast Transports
Preface ØMQ in a Hundred Words
Prototyping-the-Local-and-Cloud-Flows Putting it All Together
Chapter-Cost-of-Failure Upfront Coordination
Chapter-Model-Three-Complex-and-Nasty Conclusion
Detecting-Disappearances Group Messaging
What-s-This-Good-For Recap of Request-Reply Sockets
Chapter-The-Rolling-Stone The Pirate Gang
Chapter-Messaging-Patterns High-level Messaging Patterns
Chapter-A-Universe-of-Moving-Pieces Design for The Real World
Chapter-The-MQ-Community Architecture of the ØMQ Community
Cooperative-Discovery-using-UDP-Broadcasts Multiple Nodes on One Device
High-level-Messaging-Patterns Working with Messages
Michael-Jakl-s-Story Vadim Shalts's Story
Point-to-point-Messaging UDP Beacon Framing
-MQ-Framing Serialization Languages
Chapter-A-Shared-Key-Value-Cache-Clone-Pattern Distributing Key-Value Updates
Chapter-Shared-Queue-DEALER-and-ROUTER-sockets ØMQ's Built-in Proxy Function
One-Way-Heartbeats Ping-Pong Heartbeats
Testing-and-Simulation On Assertions
What-is-Reliability Designing Reliability
Chapter-The-Bad-the-Ugly-and-the-Delicious Trash-Oriented Design
Clone-Protocol-Specification The Espresso Pattern
Chapter-Vadim-Shalts-s-Story How the Guide Happened
Chapter-The-ZyRE-Tester Test Results
Chapter-Learning-Curve Cost of Failure
Features-of-a-Higher-Level-API The CZMQ High-Level API
Getting-the-Message-Out Divide and Conquer
Chapter-MQ-Framing Serialization Languages
Chapter-Detailed-Requirements Preventing Split-Brain Syndrome
Conclusions Discovery
The-Secret-Life-of-WiFi Why Mesh isn't Here Yet
The-Tale-of-Two-Bridges Code on the Human Scale
Invalid-Combinations Exploring ROUTER Sockets
Ephemeral-Values Clone Server Reliability
Pub-Sub-Message-Envelopes High Water Marks
Chapter-Least-Recently-Used-Routing-LRU-Pattern Address-based Routing
Step-Decide-on-the-Contracts Step 4: Write a Minimal End-to-End Solution
Chapter-Visibility Conclusions
Overview Detailed Requirements
Chapter-High-availability-Pair-Binary-Star-Pattern Overview
Tracing-Activity Dealing with Blocked Peers
Chapter-Custom-Request-Reply-Routing ROUTER-to-DEALER Routing
Chapter-Handling-Interrupt-Signals Detecting Memory Leaks
Language Goals
Simplicity-vs-Complexity Change Latency
Chapter-Multithreading-with-MQ Signaling between Threads (PAIR sockets)
Chapter-Unprotocols Why Unprotocols?
reliable-request-reply Reliable Request-Reply Patterns
Chapter-Hand-written-Binary-Serialization Code Generation
Code-on-the-Human-Scale Psychology of Software Development
Chapter-Federation-vs-Peering The Naming Ceremony
Chapter-Michael-Jakl-s-Story Vadim Shalts's Story
Idempotent-Services Disconnected Reliability (Titanic Pattern)
Chapter-Republishing-Updates Clone Subtrees
Audience-for-This-Book Getting the Examples
Chapter-Ephemeral-Values Clone Server Reliability
Shared-Queue-DEALER-and-ROUTER-sockets ØMQ's Built-in Proxy Function
Surprise-and-Expectations Economics of Participation
Chapter-Client-side-Reliability-Lazy-Pirate-Pattern Basic Reliable Queuing (Simple Pirate Pattern)
Chapter-Handling-Errors-and-ETERM Handling Interrupt Signals
The-Social-Engineer The Constant Gardener
The-ZyRE-Tester Test Results
Chapter-Distributing-Key-Value-Updates Getting a Snapshot
I-O-Threads Messaging Patterns
Economics-of-Participation Robustness in Conflict
Ask-and-Ye-Shall-Receive A Minor Note on Strings
Chapter-Initial-Design-Cut-the-API Initial Design Cut - the Protocol
Chapter-Why-make-FileMQ Initial Design Cut - the API
Transferring-Files State Machines
Chapter-The-Secret-Life-of-WiFi Why Mesh isn't Here Yet
Directory-Replication Test Use Case - The 'track' tool
Disconnected-Reliability-Titanic-Pattern High-availability Pair (Binary Star Pattern)
Zero-Copy Pub-Sub Message Envelopes
Test-Results Tracing Activity
Chapter-Care-and-Feeding The ØMQ Process - C4
Node-Coordination Zero Copy
Chapter-Goals Preliminaries
Chapter-How-to-Make-Really-Large-Architectures The Game
Least-Recently-Used-Routing-LRU-Pattern Address-based Routing
Socket-Scalability Upgrading from ØMQ/2.2 to ØMQ/3.2
Patterns-for-The-Game The Lazy Perfectionist
Creating-Stable-Releases Evolution of Public Contracts
Chapter-Scaling-to-Multiple-Clusters Federation vs. Peering
Chapter-What-is-Reliability Designing Reliability
Scaling-to-Multiple-Clusters Federation vs. Peering
Using-the-Code-Examples Acknowledgements
The-Load-balancing-Pattern ROUTER Broker and REQ Workers
Psychology-of-Software-Development The Bad, the Ugly, and the Delicious
Chapter-Prototyping-the-Local-and-Cloud-Flows Putting it All Together
Step-Write-a-Minimal-End-to-End-Solution Step 5: Solve One Problem and Repeat
The-Lazy-Perfectionist The Benevolent Tyrant
Chapter-Design-for-The-Real-World The Secret Life of WiFi
Licensing-and-Ownership Patch Requirements
Chapter-Programming-with-MQ Getting the Context Right
High-Water-Marks Missing Message Problem Solver
How-to-Make-Really-Large-Architectures The Game
Tales-from-Out-There Rob Gagnon's Story
Chapter-The-Benevolent-Tyrant The Earth and Sky
Chapter-Economics-of-Participation Robustness in Conflict
Serializing-your-Data Cheap and Nasty
Prototyping-the-State-Flow Prototyping the Local and Cloud Flows
Signaling-between-Threads-PAIR-sockets Node Coordination
The-REQ-to-REP-Combination The DEALER to REP Combination
Chapter-Service-Discovery Idempotent Services
Chapter-Some-Physics What's the Current Status?
Federation-vs-Peering The Naming Ceremony
Large-scale-File-Publishing Why make FileMQ?
Chapter-Complexity-Oriented-Design Simplicity-Oriented Design
Why-use-the-GPLv-for-Public-Specifications Using ABNF
The-Mindful-General The Social Engineer
The-Pirate-Gang The Flash Mob
Asynchronous-Client-Server Worked Example: Inter-Broker Routing
Chapter-Binary-Star-Reactor Brokerless Reliability (Freelance Pattern)
Chapter-The-Flash-Mob The Canary Watcher
Shrugging-It-Off One-Way Heartbeats
Chapter-The-Constant-Gardener The Rolling Stone
Chapter-Infinite-Property Care and Feeding
Chapter-Guarantees-of-Isolation Visibility
Chapter-A-Minor-Note-on-Strings Version Reporting
Chapter-Ask-and-Ye-Shall-Receive A Minor Note on Strings
High-availability-Pair-Binary-Star-Pattern Detailed Requirements
Address-based-Routing A Request-Reply Message Broker
Chapter-Model-Two-Brutal-Shotgun-Massacre Model Three - Complex and Nasty
Chapter-The-Historian The Provocateur
The-Request-Reply-Mechanisms The Simple Reply Envelope
Spinning-off-a-Library-Project Point-to-point Messaging
Chapter-Why-Mesh-isn-t-Here-Yet Some Physics
Chapter-The-MQ-Process-C Language
Plugging-Sockets-Into-the-Topology Using Sockets to Carry Data
Multithreading-with-MQ Signaling between Threads (PAIR sockets)
Trash-Oriented-Design Complexity-Oriented Design
On-Up-front-Testing The ZyRE Tester
Chapter-Initial-Design-Cut-the-Protocol Building and Trying FileMQ
Client-side-Reliability-Lazy-Pirate-Pattern Basic Reliable Queuing (Simple Pirate Pattern)
Chapter-Version-Reporting Getting the Message Out
Chapter-Upgrading-from-MQ-to-MQ Warning - Unstable Paradigms!
Chapter-The-Myth-of-Intelligent-Design Burnout
Chapter-High-Water-Marks Missing Message Problem Solver
Hand-written-Binary-Serialization Code Generation
File-Stability Symbolic Links
Chapter-Discovery Preemptive Discovery over Raw Sockets
The-Human-Scale The Tale of Two Bridges
Programming-with-MQ Getting the Context Right
Chapter-Group-Messaging Testing and Simulation
Step-Internalize-the-Semantics Step 2: Draw a Rough Architecture
Chapter-Zero-Copy Pub-Sub Message Envelopes
The-Constant-Gardener The Rolling Stone
Chapter-Public-API Design Notes
Chapter-Why-We-Needed-MQ Socket Scalability
Chapter-The-Canary-Watcher The Hangman
Chapter-Change-Latency Learning Curve
Chapter-Configuration File Stability
Unprotocols Why Unprotocols?
Robustness-in-Conflict Guarantees of Isolation
Chapter-True-Peer-Connectivity-Harmony-Pattern Detecting Disappearances
Exploring-ROUTER-Sockets Identities and Addresses
Chapter-Request-Reply-Envelopes Custom Request-Reply Routing
Chapter-The-Earth-and-Sky The Open Door
Chapter-Advanced-Publish-Subscribe-Patterns Slow Subscriber Detection (Suicidal Snail Pattern)
Transport-Bridging Handling Errors and ETERM
Chapter-Tracing-Activity Dealing with Blocked Peers
Chapter-The-Social-Engineer The Constant Gardener
Chapter-Clone-Server-Reliability Clone Protocol Specification
The-DEALER-to-REP-Combination The REQ to ROUTER Combination
Chapter-Getting-the-Message-Out Divide and Conquer
Chapter-Signaling-between-Threads-PAIR-sockets Node Coordination
Chapter-Divide-and-Conquer Programming with ØMQ
Chapter-MQ-in-a-Hundred-Words The Zen of Zero
The-Benevolent-Tyrant The Earth and Sky
Chapter-Patterns-for-The-Game The Lazy Perfectionist
Cost-of-Failure Upfront Coordination
Worked-Example Git Branches Considered Harmful
Chapter-Trash-Oriented-Design Complexity-Oriented Design
Identities-and-Addresses ROUTER Error Handling
Chapter-Language Goals
Chapter-The-Contract The Process
Chapter-Licensing-and-Ownership Patch Requirements
Chapter-Getting-the-Context-Right Making a Clean Exit
Service-Discovery Idempotent Services
Chapter-The-Laughing-Clown The Mindful General
Chapter-Getting-the-Examples Ask and Ye Shall Receive
postface Postface
Chapter-The-Lazy-Perfectionist The Benevolent Tyrant
On-Assertions On Up-front Testing
basics Basics
A-High-Level-API-for-MQ Making a Detour
Chapter-High-level-Messaging-Patterns Working with Messages
Reliable-Request-Reply-Patterns What is "Reliability"?
Chapter-Intermediaries-and-Proxies The Dynamic Discovery Problem
the-human-scale The Human Scale
Chapter-Prototyping-the-State-Flow Prototyping the Local and Cloud Flows
Chapter-Architecture-of-the-MQ-Community How to Make Really Large Architectures
Why-make-FileMQ Initial Design Cut - the API
Model-Two-Brutal-Shotgun-Massacre Model Three - Complex and Nasty
A-Load-Balancing-Message-Broker A High-Level API for ØMQ
Chapter-Point-to-point-Messaging UDP Beacon Framing
Using-ABNF Serializing your Data
Chapter-Multi-part-Messages Intermediaries and Proxies
Chapter-Step-Decide-on-the-Contracts Step 4: Write a Minimal End-to-End Solution
advanced-request-reply Advanced Request-Reply Patterns
Chapter-Preventing-Split-Brain-Syndrome Binary Star Implementation
Chapter-Robustness-in-Conflict Guarantees of Isolation
Chapter-Creating-Stable-Releases Evolution of Public Contracts
Chapter-Disconnected-Reliability-Titanic-Pattern High-availability Pair (Binary Star Pattern)
Chapter-Node-Coordination Zero Copy
High-speed-Subscribers-Black-Box-Pattern A Shared Key-Value Cache (Clone Pattern)
The-DEALER-to-ROUTER-Combination The DEALER to DEALER Combination
Chapter-Model-One-Simple-Retry-and-Failover Model Two - Brutal Shotgun Massacre
moving-pieces A Universe of Moving Pieces
Chapter-The-Pirate-Gang The Flash Mob
Chapter-Step-Solve-One-Problem-and-Repeat Unprotocols
The-Canary-Watcher The Hangman
Chapter-Sockets-and-Patterns The Socket API
Chapter-ROUTER-to-DEALER-Routing Least-Recently Used Routing (LRU Pattern)
Design-for-The-Real-World The Secret Life of WiFi
Reliabilty Configuration
Design-Notes Reliabilty
Chapter-Using-ABNF Serializing your Data
Chapter-Advanced-Request-Reply-Patterns The Request-Reply Mechanisms
What-s-the-Current-Status Conclusions
ROUTER-to-DEALER-Routing Least-Recently Used Routing (LRU Pattern)
Contracts-and-Protocols Service-Oriented Reliable Queuing (Majordomo Pattern)
Chapter-Tom-van-Leeuwen-s-Story Michael Jakl's Story
Brokerless-Reliability-Freelance-Pattern Model One - Simple Retry and Failover
Chapter-Plugging-Sockets-Into-the-Topology Using Sockets to Carry Data
Chapter-Simplicity-vs-Complexity Change Latency
The-Espresso-Pattern Last Value Caching
The-Asynchronous-Client-Server-Pattern Worked Example: Inter-Broker Routing
The-Socket-API Plugging Sockets Into the Topology
Chapter-More-about-UDP Spinning off a Library Project
Chapter-Psychology-of-Software-Development The Bad, the Ugly, and the Delicious
Chapter-The-Naming-Ceremony Prototyping the State Flow
Chapter-Using-the-Code-Examples Acknowledgements
Chapter-Serialization-Libraries Hand-written Binary Serialization
Chapter-Worked-Example-Inter-Broker-Routing Establishing the Details
Step-Solve-One-Problem-and-Repeat Unprotocols
Git-Branches-Considered-Harmful Simplicity vs. Complexity
The-CZMQ-High-Level-API The Asynchronous Client-Server Pattern
Discovery Preemptive Discovery over Raw Sockets
Authentication-using-SASL Large-scale File Publishing
Heartbeating-for-Paranoid-Pirate Contracts and Protocols
Chapter-State-Machines Authentication using SASL
Chapter-Evolution-of-Public-Contracts Worked Example
Stranger-meet-Stranger Infinite Property
Chapter-Asynchronous-Client-Server Worked Example: Inter-Broker Routing
Advanced-Publish-Subscribe-Patterns Slow Subscriber Detection (Suicidal Snail Pattern)
The-Naming-Ceremony Prototyping the State Flow
Fixing-the-World Audience for This Book
Chapter-Audience-for-This-Book Getting the Examples
Chapter-The-Process Crazy, Beautiful, and Easy
The-Open-Door The Laughing Clown
Preventing-Split-Brain-Syndrome Binary Star Implementation
The-Earth-and-Sky The Open Door
Model-One-Simple-Retry-and-Failover Model Two - Brutal Shotgun Massacre
Custom-Request-Reply-Routing ROUTER-to-DEALER Routing
Care-and-Feeding The ØMQ Process - C4
Simplicity-Oriented-Design Message Oriented Pattern for Elastic Design
Getting-the-Context-Right Making a Clean Exit
Chapter-Designing-the-API More about UDP
Chapter-Dealing-with-Blocked-Peers More Coming Soon
Chapter-A-Request-Reply-Message-Broker A High-Level API for ØMQ
Chapter-The-Open-Door The Laughing Clown
Detailed-Requirements Preventing Split-Brain Syndrome
-MQ-in-a-Hundred-Words The Zen of Zero
Handling-Multiple-Sockets Multi-part Messages
Version-Reporting Getting the Message Out
Chapter-The-Espresso-Pattern Last Value Caching
advanced-pub-sub Advanced Publish-Subscribe Patterns
Chapter-Heartbeating Shrugging It Off
Distributing-Key-Value-Updates Getting a Snapshot
Test-Use-Case-The-track-tool Getting an Official Port Number
Visibility Conclusions
Serialization-Languages Serialization Libraries
Chapter-Git-Branches-Considered-Harmful Simplicity vs. Complexity
Chapter-UDP-Beacon-Framing True Peer Connectivity (Harmony Pattern)
Chapter-Reliabilty Configuration
Chapter-Step-Write-a-Minimal-End-to-End-Solution Step 5: Solve One Problem and Repeat
Chapter-Contracts-and-Protocols Service-Oriented Reliable Queuing (Majordomo Pattern)
Chapter-Design-Notes Reliabilty
Chapter-Brokerless-Reliability-Freelance-Pattern Model One - Simple Retry and Failover
Learning-Curve Cost of Failure
Cheap-and-Nasty ØMQ Framing
Chapter-Why-Unprotocols How to Write Unprotocols
UDP-Beacon-Framing True Peer Connectivity (Harmony Pattern)
Chapter-Internal-Architecture Public API
Chapter-Architecture-of-a-Single-Cluster Scaling to Multiple Clusters
The-DEALER-to-DEALER-Combination The ROUTER to ROUTER Combination
Why-Unprotocols How to Write Unprotocols
Chapter-Robust-Reliable-Queuing-Paranoid-Pirate-Pattern Heartbeating
Chapter-Basic-Reliable-Queuing-Simple-Pirate-Pattern Robust Reliable Queuing (Paranoid Pirate Pattern)
Internal-Architecture Public API
Serialization-Libraries Hand-written Binary Serialization
A-Request-Reply-Message-Broker A High-Level API for ØMQ
The-Game The Contract
The-MQ-Process-C Language
Sockets-and-Patterns The Socket API
Distributed-Logging-and-Monitoring A Plausible Minimal Implementation
Chapter-Step-Draw-a-Rough-Architecture Step 3: Decide on the Contracts
The-Contract The Process
Multi-part-Messages Intermediaries and Proxies
Chapter-Removing-Friction Licensing
The-Historian The Provocateur
Chapter-Crazy-Beautiful-and-Easy Stranger, meet Stranger
Chapter-Clone-Subtrees Ephemeral Values
Basic-Reliable-Queuing-Simple-Pirate-Pattern Robust Reliable Queuing (Paranoid Pirate Pattern)
Chapter-Shrugging-It-Off One-Way Heartbeats
Building-and-Trying-FileMQ Internal Architecture
Chapter-Test-Results Tracing Activity
Chapter-Upfront-Coordination Scalability
Designing-the-API More about UDP
Designing-Reliability Client-side Reliability (Lazy Pirate Pattern)
Chapter-Service-Oriented-Reliable-Queuing-Majordomo-Pattern Asynchronous Majordomo Pattern
Why-Mesh-isn-t-Here-Yet Some Physics
Chapter-I-O-Threads Messaging Patterns
Ping-Pong-Heartbeats Heartbeating for Paranoid Pirate
Chapter-Simplicity-Oriented-Design Message Oriented Pattern for Elastic Design
Chapter-The-Game The Contract
Preliminaries Licensing and Ownership
Chapter-Scalability Surprise and Expectations
Chapter-MQ-s-Built-in-Proxy-Function Transport Bridging
Change-Latency Learning Curve
The-Hangman The Historian
Request-Reply-Envelopes Custom Request-Reply Routing
Chapter-Conclusions Discovery
Chapter-Pub-Sub-Message-Envelopes High Water Marks
The-Laughing-Clown The Mindful General
The-Simple-Reply-Envelope The Extended Reply Envelope
Chapter-Handling-Multiple-Sockets Multi-part Messages
Chapter-Slow-Subscriber-Detection-Suicidal-Snail-Pattern High-speed Subscribers (Black Box Pattern)
The-Provocateur The Mystic
Chapter-Worked-Example Git Branches Considered Harmful
Chapter-Message-Oriented-Pattern-for-Elastic-Design Step 1: Internalize the Semantics
Asynchronous-Majordomo-Pattern Service Discovery
Chapter-Code-Generation Transferring Files
Chapter-High-speed-Subscribers-Black-Box-Pattern A Shared Key-Value Cache (Clone Pattern)
Chapter-Code-on-the-Human-Scale Psychology of Software Development
Robust-Reliable-Queuing-Paranoid-Pirate-Pattern Heartbeating
Clone-Subtrees Ephemeral Values
The-REQ-to-ROUTER-Combination The DEALER to ROUTER Combination
Chapter-Rob-Gagnon-s-Story Tom van Leeuwen's Story
sockets-and-patterns Sockets and Patterns
The-Extended-Reply-Envelope What's This Good For?
Chapter-Tales-from-Out-There Rob Gagnon's Story
Chapter-Unicast-Transports ØMQ is Not a Neutral Carrier
Handling-Errors-and-ETERM Handling Interrupt Signals
Chapter-Preliminaries Licensing and Ownership
True-Peer-Connectivity-Harmony-Pattern Detecting Disappearances
Unicast-Transports ØMQ is Not a Neutral Carrier
Establishing-the-Details Architecture of a Single Cluster
Chapter-Step-Internalize-the-Semantics Step 2: Draw a Rough Architecture
Chapter-Getting-a-Snapshot Republishing Updates
ROUTER-Error-Handling The Load-balancing Pattern
Chapter-Why-use-the-GPLv-for-Public-Specifications Using ABNF
The-Bad-the-Ugly-and-the-Delicious Trash-Oriented Design
Scalability Surprise and Expectations
Initial-Design-Cut-the-Protocol Building and Trying FileMQ
Worked-Example-Inter-Broker-Routing Establishing the Details
Removing-Friction Licensing
-MQ-s-Built-in-Proxy-Function Transport Bridging
Patch-Requirements Development Process
Chapter-The-Zen-of-Zero How the Guide Happened
Chapter-What-s-the-Current-Status Conclusions
Detecting-Memory-Leaks Multithreading with ØMQ
The-Dynamic-Discovery-Problem Shared Queue (DEALER and ROUTER sockets)
Chapter-Working-with-Messages Handling Multiple Sockets
How-to-Write-Unprotocols Why use the GPLv3 for Public Specifications?
Chapter-Basics Fixing the World
Chapter-Transferring-Files Heartbeating
Conventions-Used-in-This-Book Using the Code Examples
Chapter-Address-based-Routing A Request-Reply Message Broker
Some-Physics What's the Current Status?
The-Myth-of-Intelligent-Design Burnout
Getting-the-Examples Ask and Ye Shall Receive
Chapter-One-Way-Heartbeats Ping-Pong Heartbeats
The-MQ-Community Architecture of the ØMQ Community
Chapter-Building-and-Trying-FileMQ Internal Architecture
Message-Oriented-Pattern-for-Elastic-Design Step 1: Internalize the Semantics
Recap-of-Request-Reply-Sockets Request-Reply Combinations
Dealing-with-Blocked-Peers Distributed Logging and Monitoring
Guarantees-of-Isolation Visibility
Public-API Design Notes
Chapter-Transport-Bridging Handling Errors and ETERM
A-Universe-of-Moving-Pieces Design for The Real World
Chapter-Designing-Reliability Client-side Reliability (Lazy Pirate Pattern)
Chapter-How-the-Guide-Happened Removing Friction
Chapter-Patch-Requirements Development Process
Chapter-Overview Detailed Requirements
Request-Reply-Combinations The REQ to REP Combination
Chapter-The-Provocateur The Mystic
Chapter-Stranger-meet-Stranger Infinite Property
Republishing-Updates Clone Subtrees
Architecture-of-a-Single-Cluster Scaling to Multiple Clusters
Audience Acknowledgements
Model-Three-Complex-and-Nasty Conclusion
Chapter-On-Up-front-Testing The ZyRE Tester
Development-Process Creating Stable Releases
Getting-a-Snapshot Republishing Updates
The-Rolling-Stone The Pirate Gang
Infinite-Property Care and Feeding
Postface Tales from Out There
Making-a-Detour Features of a Higher-Level API
Chapter-MQ-is-Not-a-Neutral-Carrier I/O Threads
State-Machines Authentication using SASL
Complexity-Oriented-Design Simplicity-Oriented Design
More-about-UDP Spinning off a Library Project
Multiple-Nodes-on-One-Device Designing the API
Chapter-Clone-Protocol-Specification The Espresso Pattern
Chapter-Idempotent-Services Disconnected Reliability (Titanic Pattern)
Intermediaries-and-Proxies The Dynamic Discovery Problem
Evolution-of-Public-Contracts Worked Example
The-Process Crazy, Beautiful, and Easy
Chapter-Large-scale-File-Publishing Why make FileMQ?
Chapter-Fixing-the-World Audience for This Book
Rob-Gagnon-s-Story Tom van Leeuwen's Story
Clone-Server-Reliability Clone Protocol Specification
Code-Generation Transferring Files
Handling-Interrupt-Signals Detecting Memory Leaks
