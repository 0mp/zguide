++ Chapter 3 - Advanced Stuff

In chapter 2 we worked through the basics of using 0MQ by developing a series of small applications, each time exploring new aspects of 0MQ.  We'll continue this approach in chapter 3, as we explore advanced aspects of 0MQ.

We'll cover:

* How to create and use message envelopes for pubsub and request-reply.
* How the request-reply pattern works, in detail, including XREQ and XREP.
* The concept of //identities// and what they are used for.

+++ Message Envelopes

We looked briefly at multipart messages in chapter 2.  Let's now look at their main use case, which is to create message envelopes.  An envelope is a way of safely packaging up data with an address, without touching the data itself.

0MQ has two main use cases for message envelopes:

* In the pubsub pattern, where the envelope holds the subscription key for filtering.
* In the reqrep pattern, where the envelope holds the return address for replies.

In a high-performance world, we don't want to copy data.  The problem with traditional message framing is that to create a message composed of pieces, we have to copy stuff around, and this costs CPU cycles.  0MQ's multipart message format lets us work with a message in pieces, while using zero copy.  We send each field as a length-delimited frame.  To the application it looks like a series of send and recv calls.  But internally the multiple parts get written to the network and read back with single system calls, so it's very efficient.

++++ Pubsub Message Envelopes

If you want to use pubsub envelopes, you make them yourself.  It's optional, and in previous pubsub examples we didn't do this.  Using a pubsub envelope is a little more work for simple cases but it's cleaner especially for real cases, where the key and the data are naturally separate things.  It's also faster, if you are writing the data directly from an application buffer.

Here is what a publish-subscribe message with an envelope looks like:

[[code type="textdiagram"]]
            +-------------+
  Frame 1   |     Key     |     This is the envelope
            +-------------+

            +-----------------------------------------+
  Frame 2   |     Data                                |
            +-----------------------------------------+


           Figure # - Multipart pubsub message
[[/code]]

Recall that pubsub matches messages based on the prefix.  Putting the key into a separate frame makes the matching very obvious, since there is no chance an application will accidentally match on part of the data.

Here is a minimalist example of how pubsub envelopes look in code.  This publisher sends messages of two types, A and B.  The envelope holds the message type:

[[code type="C" title="Pubsub envelope publisher" name="psenvpub"]]
[[/code]]

The subscriber only wants messages of type B:

[[code type="C" title="Pubsub envelope subscriber" name="psenvsub"]]
[[/code]]

When you run the two programs, the subscriber should show you this:

[[code]]
[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
...
[[/code]]

This examples shows that the subscription filter rejects or accepts the entire multipart message (key plus data).  You won't get part of a multipart message, ever.

++++ Request-Reply Message Envelopes

For the request-reply case, 0MQ always creates and uses envelopes and you don't need to understand how they work to use them.  Firstly, when you use REQ and REP, your sockets build and use envelopes automatically.  Second, when you write a device, and we covered this in the last chapter, you just need to read and write all the parts of a message.

However, getting under the hood and playing with request-reply envelopes is profitable.  It's time to explain how XREP works.  This is really a //request-reply router//:

* When you receive a message from an XREP socket, it shoves a brown paper envelope around the message and scribbles on with indelible ink, "This came from Joe Blogs".  Then it gives that to you.  That is, the XREP socket gives you what came off the wire, wrapped up in an envelope with the reply address on it.

* when you send a message to an XREP socket, it rips off that brown paper envelope, tries to read its own handwriting, and if it knows who "Joe Blogs" is, sends the contents back to Joe.  That is the reverse process of receiving a message.

If you leave the brown envelope alone, and then pass that message to another XREP socket (e.g. by sending to an XREQ connected to an XREP), the second XREP socket will in turn stick another brown envelope on it, and scribble the name of that XREQ on it.

The whole point of this is that each XREP knows how to send replies back to the right place.  All you need to do, in your application, is respect the brown envelopes.  Now the REP socket makes sense.  It carefully slices open the brown envelopes, one by one, keeps them safely aside, and gives you the original message.  When you send the reply, it re-wraps the reply in the brown paper envelopes, so that it can hand that back to the XREP sockets down the chain.

Which lets you insert XREP-XREQ devices into a request-reply pattern like this:

[[code]]
[REQ] <--> [REP]
[REQ] <--> [XREP--XREQ] <--> [REP]
[REQ] <--> [XREP--XREQ] <--> [XREP--XREQ] <--> [REP]
...etc.
[[/code]]

If you connect a REQ socket to an XREP socket, and send one request message, this is what you get when you receive from the XREP socket:

[[code type="textdiagram"]]
            +--------------+
  Frame 1   |   Identity   |
            +--------------+

            +---+
  Frame 2   |   |   <------ Empty message part
            +---+

            +-----------------------------------------+
  Frame 3   |     Data                                |
            +-----------------------------------------+


       Figure # - Single-hop request-reply envelope
[[/code]]

Now if we extend this with a chain of devices, we get envelope wrapping envelope, with the newest envelope always stuck at the beginning of the stack:

[[code type="textdiagram"]]

       (Next envelope will go here)

            +--------------+
  Frame 1   |  Envelope 3  |
            +--------------+

            +--------------+
  Frame 2   |  Envelope 2  |
            +--------------+

            +--------------+
  Frame 3   |  Envelope 1  |
            +--------------+

            +---+
  Frame 4   |   |   <------ Empty message part
            +---+

            +-----------------------------------------+
  Frame 5   |     Data                                |
            +-----------------------------------------+


       Figure # - Multihop request-reply envelope
[[/code]]

Here now is an explanation of the four socket types we use for request-reply patterns:

* XREQ just load-balances the messages you send to all connected nodes, and fair-queues the messages it receives.  It is exactly like a PUSH and PULL socket combined.

* REQ prepends an empty message part to every message you send, and removes the empty message part from each message you receive.  It then works just like XREQ (and in fact is built on XREQ).

* XREP prepends a message part containing the peer's identity to each message it receives, before passing it to the application.  It also chops off the first message part from every message it sends, and uses that to decide which peer the message should go to.

* REP stores all the message parts up to the first empty message part, when you receive a message and it passes the rest (the data) to your application.  When you send a reply, REP prepends the saved envelopes to the message and sends it back using the same semantics as XREP (and in fact REP is built on top of XREP).

REP requires that the envelopes end with an empty message part.  If you're not using REQ at the other end of the chain then you must add the empty message part yourself.

+++ Identities


- use cases for identities
    - automatic, for routing replies back
    - explicit, for persistent queues
- when do identities cause problems?
    - if used in pubsub without SWAP
